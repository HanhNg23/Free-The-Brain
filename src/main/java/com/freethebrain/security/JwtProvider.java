package com.freethebrain.security;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import com.freethebrain.config.AppProperties;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;

/*
 * This class contains code to generate Token + verify JWT
*/
@Service
public class JwtProvider {

    private static final Logger logger = LoggerFactory.getLogger(JwtProvider.class);
    
    @Autowired
    private AppProperties appProperties;

	public JwtProvider(AppProperties appProperties) {
		this.appProperties = appProperties;
	}

	public String createAccessToken(Authentication authentication) {
		UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

		Date now = new Date();
		Date accessTokenExpiryDate = new Date(now.getTime() + appProperties.getAuth().getAccessTokenExpirationMsec());

		String token = Jwts.builder()
				.setSubject(userPrincipal.getId())// Use userId for identify of current authenticated user
				.setIssuedAt(new Date()) // when token is created
				.setExpiration(accessTokenExpiryDate) // when token expired
				.signWith(this.getSigningKey(), SignatureAlgorithm.HS512)// Signs the constructed JWT with the secret key using the algorithm HS512 - can choose other
				.compact();// Builds the JWT and serializes it to a compact
		return token;
	}

	public String createRefresfToken(Authentication authentication) {
		UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

		Date now = new Date();
		Date refreshTokenExpiryDate = new Date(now.getTime() + appProperties.getAuth().getRefreshTokenExpirationMsec());

		String token = Jwts.builder()
				.setSubject(userPrincipal.getId())// use userId for identify
				.setIssuedAt(new Date())
				.setExpiration(refreshTokenExpiryDate)
				.signWith(this.getSigningKey(), SignatureAlgorithm.HS512)
				.compact();
		return token;
	}

	public Claims extractTokenClaims(String token) {
		System.out.println("Token ===== " + token);
		Claims claims = Jwts.parserBuilder()
				.setSigningKey(this.getSigningKey())
				.build()
				.parseClaimsJws(token)
				.getBody();
		return claims;
	}

	public String extractUserIdFromToken(String token) {
		String userId = this.extractSpecificTokenClaim(token, Claims::getSubject);
		return userId;
	}

	public Date extractTokenExpirationDate(String token) {
		return this.extractSpecificTokenClaim(token, Claims::getExpiration);
	}

    /*
     * when parseClaimsJws will throw these exception -- UnsupportedJwtException -
     * if the claimsJws argument does not represent an Claims JWS --
     * MalformedJwtException - if the claimsJws string is not a valid JWS --
     * SignatureException - if the claimsJws JWS signature validation fails --
     * ExpiredJwtException - if the specified JWT is a Claims JWT and the Claims has
     * an expiration timebefore the time this method is invoked. --
     * IllegalArgumentException - if the claimsJws string is null or empty or only
     * whitespace
     */

	public boolean validateToken(String authToken) {
		try {
			this.extractTokenClaims(authToken);
			return true;
		} catch (SignatureException ex) {
			logger.error("Invalid JWT signature !");// this is not the token which is generated by this app
		} catch (MalformedJwtException ex) {
			logger.error("Unconstructed JWT token ! ");
		} catch (ExpiredJwtException ex) {
			logger.error("Expired JWT token !");
		} catch (UnsupportedJwtException ex) {
			logger.error("Unsupported JWT token !");
		} catch (IllegalArgumentException ex) {
			logger.error("JWT claims is null or empty or blank !");
		}
		return false;
	}

	public <T> T extractSpecificTokenClaim(String token, Function<Claims, T> claímResolver) {
		final Claims claims = this.extractTokenClaims(token);
		return claímResolver.apply(claims);

	}

	private Key getSigningKey() {
		return Keys.hmacShaKeyFor(Decoders.BASE64.decode(appProperties.getAuth().getTokenSecret()));
	}
}
